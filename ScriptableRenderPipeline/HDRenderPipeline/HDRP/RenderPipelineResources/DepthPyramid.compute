#include "CoreRP/ShaderLibrary/Common.hlsl"

// ------------------------------------------------
// Algorithm
// ------------------------------------------------
// Downsample a depth texture by taking min value of sampled pixels
// It also handles computing in a viewport of a texture.
// When we use partial kernels there are only 4 patterns (first is full): 
//  0.  |x|x|       1.  |x|o|       2.  |o|o|       3.  |o|o|
//      |x|x|           |x|o|           |x|x|           |x|o|

// ------------------------------------------------
// Variants
// ------------------------------------------------

#pragma kernel KDepthDownSample8                    KERNEL_SIZE=8       PATTERN=0       KERNEL_NAME=KDepthDownSample8    
#pragma kernel KDepthDownSample2_0                  KERNEL_SIZE=1       PATTERN=0       KERNEL_NAME=KDepthDownSample2_0
#pragma kernel KDepthDownSample2_1                  KERNEL_SIZE=1       PATTERN=1       KERNEL_NAME=KDepthDownSample2_1
#pragma kernel KDepthDownSample2_2                  KERNEL_SIZE=1       PATTERN=2       KERNEL_NAME=KDepthDownSample2_2
#pragma kernel KDepthDownSample2_3                  KERNEL_SIZE=1       PATTERN=3       KERNEL_NAME=KDepthDownSample2_3

#pragma only_renderers d3d11 ps4 xboxone vulkan metal

// ------------------------------------------------
// Texture buffers
// ------------------------------------------------

Texture2D<float> _Source;
RWTexture2D<float> _Result;

SamplerState sampler_PointClamp;    //TODO: could we use min-sampler instead of using ALU?

// ------------------------------------------------
// Constant buffers
// ------------------------------------------------
CBUFFER_START(cb)
float4 _SrcSize;
uint2 _RectOffset;
CBUFFER_END

// ------------------------------------------------
// Kernel
// ------------------------------------------------

[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void KERNEL_NAME(uint2 groupId : SV_GroupID, uint2 groupThreadId : SV_GroupThreadID, uint2 dispatchThreadId : SV_DispatchThreadID)
{
    // Upper-left pixel coordinate of quad that this thread will read
    uint2 threadUL = dispatchThreadId << 1;

    // Downsample the block
    float2 offset = _RectOffset + float2(threadUL);

#if defined(PLATFORM_SUPPORT_GATHER)
    //offset += 1; // Offset by one to have proper location for gather
    float4 depths = GATHER_RED_TEXTURE2D(_Source, sampler_PointClamp, offset * _SrcSize.zw, 0.0).wzxy;
#else
    // Downsample the block
    float p00 = SAMPLE_TEXTURE2D_LOD(_Source, sampler_PointClamp, (offset) * _SrcSize.zw, 0.0).x;
    float p10 = SAMPLE_TEXTURE2D_LOD(_Source, sampler_PointClamp, (offset + float2(1.0, 0.0)) * _SrcSize.zw, 0.0).x;
    float p01 = SAMPLE_TEXTURE2D_LOD(_Source, sampler_PointClamp, (offset + float2(0.0, 1.0)) * _SrcSize.zw, 0.0).x;
    float p11 = SAMPLE_TEXTURE2D_LOD(_Source, sampler_PointClamp, (offset + float2(1.0, 1.0)) * _SrcSize.zw, 0.0).x;
    float4 depths = float4(p00, p10, p01, p11);
#endif

#if UNITY_REVERSED_Z
# define MIN_OP(l, r) max(l, r)
#else
# define MIN_OP(l, r) min(l, r)
#endif

    // Select the nearest sample
#if PATTERN == 0
    float minDepth = MIN_OP(MIN_OP(depths.x, depths.y), MIN_OP(depths.z, depths.w));
#elif PATTERN == 1
    float minDepth = MIN_OP(depths.x, depths.z);
#elif PATTERN == 2
    float minDepth = MIN_OP(depths.x, depths.y);
#elif PATTERN == 3
    float minDepth = depths.x;
#endif

#undef MIN_OP

    // Write to the final target
    _Result[dispatchThreadId] = minDepth;

    if (_RectOffset.x == 0 && _RectOffset.y == 0)
        _Result[dispatchThreadId] = 1;
    if (_RectOffset.x != 0 && _RectOffset.y == 0)
        _Result[dispatchThreadId] = 0;
    if (_RectOffset.x == 0 && _RectOffset.y != 0)
        _Result[dispatchThreadId] = 0;
    if (_RectOffset.x != 0 && _RectOffset.y != 0)
        _Result[dispatchThreadId] = 0;
}
