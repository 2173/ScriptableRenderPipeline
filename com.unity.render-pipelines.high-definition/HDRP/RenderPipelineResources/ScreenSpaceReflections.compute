#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// -------------------------------------------------
// Screen Space Reflection
// -------------------------------------------------
// Proxy passes
// 1. Cast Rays
// 2. Resolve color
//
// Raytracing passes
// 1. Clear buffers
// 2. Allocate rays
// 3. Cast rays
// 4. Resolve color
// -------------------------------------------------

#define PASS_CLEAR 0
#define PASS_CAST_RAYS 1
#define PASS_ALLOCATE_RAYS 2
#define PASS_RESOLVE 3

// -------------------------------------------------
// Kernels Settings
// -------------------------------------------------
// Kernel settings
#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64

#if PASS == PASS_CLEAR
#elif PASS == PASS_CAST_RAYS
#elif PASS == PASS_ALLOCATE_RAYS
    #define USE_COMPRESSED_BAYER4
#endif

// -------------------------------------------------
// Kernels
// -------------------------------------------------
#pragma kernel KClear                       KNAME=KClear                    PASS=PASS_CLEAR
#pragma kernel KAllocateRays_HiZ            KNAME=KAllocateRays_HiZ         PASS=PASS_ALLOCATE_RAYS
#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PASS=PASS_CAST_RAYS
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PASS=PASS_CAST_RAYS         DEBUG_DISPLAY
#pragma kernel KResolve                     KNAME=KResolve                  PASS=PASS_RESOLVE

// -------------------------------------------------
// Common includes of passes
// -------------------------------------------------
#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#define LIGHTLOOP_TILE_PASS 1
// deferred opaque always use FPTL
#define USE_FPTL_LIGHTLIST 1
#include "CoreRP/ShaderLibrary/GeometricTools.hlsl"
#include "CoreRP/ShaderLibrary/ImageBasedLighting.hlsl"
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl
#include "HDRP/ShaderVariables.hlsl"
#include "HDRP/Debug/DebugDisplay.hlsl"
#include "HDRP/Material/Material.hlsl"
#include "HDRP/Material/Builtin/BuiltinData.hlsl"
#include "HDRP/Material/Lit/Lit.cs.hlsl"
#include "HDRP/Lighting/LightDefinition.cs.hlsl"
#include "HDRP/Lighting/Reflection/VolumeProjection.hlsl"
#ifdef DEBUG_DISPLAY
#include "CoreRP/ShaderLibrary/Debug.hlsl"
#endif

// -------------------------------------------------
// Common
// -------------------------------------------------
struct AllocationPayload
{
    uint2 positionSS;
};

uint EncodeAllocationPayload(AllocationPayload payload)
{
    return (payload.positionSS.x & 0xFFFF) | (payload.positionSS.y << 16);
}

AllocationPayload DecodeAllocationPayload(uint payload)
{
    AllocationPayload result;
    result.positionSS.x = (payload & 0xFFFF);
    result.positionSS.y = payload >> 16;
    return result;
}

uint GetIndex(uint2 groupId, uint groupThreadId)
{
    uint groupPerRow = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    return groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D + 3;
}

void DecodeSSRBuffer(uint2 positionSS, out float3 normalWS, out float perceptualRoughness)
{
    BSDFData bsdfData;
    BakeLightingData bakeLightingData;
    DECODE_FROM_GBUFFER(positionSS, 0, bsdfData, bakeLightingData.bakeDiffuseLighting);
    normalWS            = bsdfData.normalWS;
    perceptualRoughness = bsdfData.perceptualRoughness;
}

// #################################################
// Pass: Clear
// #################################################
// Clear buffers
// -------------------------------------------------
#if PASS == PASS_CLEAR

RWBuffer<uint>      _PayloadIndirect;

[numthreads(1, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    // Clear allocated dispatch indirect buffer
    _PayloadIndirect[0] = 0;
    _PayloadIndirect[1] = 1;
    _PayloadIndirect[2] = 1;
}

// #################################################
// Pass: Allocate Rays
// #################################################
// HiZ only
// Calculate initialization values for HiZ algorithm
// -------------------------------------------------
#elif PASS == PASS_ALLOCATE_RAYS

RWBuffer<uint>                  _PayloadIndirect;
RWBuffer<uint>                  _Payload;  // Indirect argument must be in Buffer
RWStructuredBuffer<float4>      _Payload1; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
RWStructuredBuffer<float4>      _Payload2; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4

// -------------------------------------------------
// Entry point: Allocate Rays
// -------------------------------------------------
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    if (groupThreadId == 0)
        InterlockedAdd(_PayloadIndirect[0], 1);

    groupThreadId &= GROUP_SIZE_2D - 1;

    uint groupPerRow        = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    uint index              = groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D;
    uint2 groupCoord        = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord  = DecodeMorton2D(groupThreadId);
    uint2 positionSS        = groupCoord + groupThreadCoord;

    // Decode Buffer
    float depth                 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionSS, 0).x;
    PositionInputs posInput     = GetPositionInput(positionSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, int2(0, 0));
    float3 V                    = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    float3 positionWS           = posInput.positionWS;
    float3 normalWS;
    float perceptualRoughness;
    DecodeSSRBuffer(positionSS, normalWS, perceptualRoughness);

    // Calculate ray endpoints
    float3 rayOriginWS              = positionWS;
    float3 rayDirWS                 = reflect(-V, normalWS);

    float3 startPositionSS;
    float3 endPositionSS;
    CalculateRayEndPointSS(
        rayOriginWS + rayDirWS * SampleBayer4(positionSS + uint2(_FrameCount, uint(_FrameCount) / 4u)) * 0.1,
        rayDirWS,
        uint2(_DepthPyramidSize.xy),
        startPositionSS,
        endPositionSS
    );

    // Save payload
    AllocationPayload allocationPayload;
    allocationPayload.positionSS = positionSS;

    _Payload[index]     = EncodeAllocationPayload(allocationPayload);
    _Payload1[index]    = float4(startPositionSS, perceptualRoughness);
    _Payload2[index]    = float4(endPositionSS, 1);
}

// #################################################
// Pass: Cast Rays
// #################################################
// Cast rays in screen space and store the hit in a buffer
// -------------------------------------------------
#elif PASS == PASS_CAST_RAYS

// Resources
RW_TEXTURE2D(uint4, _SSReflectionRayHitNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4, _DebugTexture);
#endif

Buffer<uint>                _Payload;
StructuredBuffer<float4>    _Payload1; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
StructuredBuffer<float4>    _Payload2; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
Texture2D<uint4>            _SSReflectionRayAllocationTexture;

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint dispatchThreadID : SV_DispatchThreadID
)
{
    uint index                      = dispatchThreadID;
    
    // Read allocation payload
    AllocationPayload allocation    = DecodeAllocationPayload(_Payload[index]);
    uint2 positionSS                = allocation.positionSS;
    float3 startRayPositionSS       = _Payload1[index].xyz;
    float perceptualRoughness       = _Payload1[index].w;
    float3 endRayPositionSS         = _Payload2[index].xyz;
    float3 raySS                    = endRayPositionSS - startRayPositionSS;

    // Screen space tracing query
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;
    float hitWeight = 1;

    ScreenSpaceRaymarchInputPrecomputed ssRayInput;
    ssRayInput.startPositionSS      = startRayPositionSS;
    ssRayInput.raySS                = raySS;
#ifdef DEBUG_DISPLAY
    ssRayInput.debug                = _DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(allocation.positionSS));
#endif

    hitSuccessful = ScreenSpaceHiZRaymarchPrecomputedReflection(ssRayInput, hit, hitWeight);

    uint4 outputPayload = uint4(0, 0, 0, 0);
    EncodeRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, perceptualRoughness, outputPayload);

    _SSReflectionRayHitNextTexture[positionSS] = outputPayload;
#ifdef DEBUG_DISPLAY
    _DebugTexture[positionSS] = float4(hit.debugOutput, 1);
#endif
}


// #################################################
// Pass: Resolve
// #################################################
// Resolve the color in a specific buffer
// -------------------------------------------------
#elif PASS == PASS_RESOLVE

// Resources
Texture2D<uint4> _SSReflectionRayHitNextTexture;
RW_TEXTURE2D(float4, _SSReflectionResolveNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4, _DebugTexture);
#endif

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    uint groupPerRow            = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    uint index                  = groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D;
    uint2 groupCoord            = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord      = DecodeMorton2D(groupThreadId);
    uint2 positionSS            = groupCoord + groupThreadCoord;
    float perceptualRoughness   = 0;
    uint2 hitPositionSS         = uint2(0, 0);
    float2 hitPositionNDC       = float2(0, 0);
    float hitWeight             = 0;
    bool hitSuccessful          = false;
    
    uint4 payload = asuint(LOAD_TEXTURE2D_LOD(_SSReflectionRayHitTexture, positionSS, 0));
    DecodeRayHit(payload, hitPositionSS, hitPositionNDC, hitWeight, hitSuccessful, perceptualRoughness);

    int mipLevel                = PositivePow(perceptualRoughness, 0.8) * uint(max(_ColorPyramidScale.z - 1, 0));

    // Fade pixels near the texture buffers' borders
    float2  weightNDC = clamp(min(hitPositionNDC, 1 - hitPositionNDC) * _SSReflectionInvScreenWeightDistance, 0, 1);
            weightNDC = weightNDC * weightNDC * (3 - 2 * weightNDC);
    // TODO: Fade pixels with normal non facing the ray direction
    // TODO: Fade pixels marked as foreground in stencil
    float weight = weightNDC.x * weightNDC.y * hitWeight;

    if (weight == 0)
    {
        _SSReflectionResolveNextTexture[positionSS] = 0;
        return;
    }

    // Reproject color pyramid
    float4 color = float4(0, 0, 0, 0);
    {
        float4 hitVelocityBuffer = LOAD_TEXTURE2D_LOD(
            _CameraMotionVectorsTexture,
            hitPositionSS,
            0.0
        );

        float2 hitVelocityNDC;
        DecodeVelocity(hitVelocityBuffer, hitVelocityNDC);

        color = SAMPLE_TEXTURE2D_LOD(
            _ColorPyramidTexture,
            s_trilinear_clamp_sampler,
            // Offset by half a texel to properly interpolate between this pixel and its mips
            (hitPositionNDC - hitVelocityNDC) * _ColorPyramidScale.xy + _ColorPyramidSize.zw * 0.5,
            mipLevel
        );
    }
    
    // With HiZ, we use a temporal filtering to reduce the noise from the ray origin jittering
    {
        float temporalFilteringWeight   = 0.1;
        float4 currentVelocityBuffer = LOAD_TEXTURE2D_LOD(
            _CameraMotionVectorsTexture,
            positionSS,
            0.0
        );

        float2 currentVelocityNDC;
        DecodeVelocity(currentVelocityBuffer, currentVelocityNDC);

        float4 currentLD = LOAD_TEXTURE2D_LOD(
            _ColorPyramidTexture,
            int2(positionSS) - int2(currentVelocityNDC * _ScreenSize.xy),
            0
        );
        color = color * (1.0 - temporalFilteringWeight) + currentLD * temporalFilteringWeight;
    }

    color.a = weight;

#ifdef DEBUG_DISPLAY
    if (_DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION)
    {
        bool applyDebug = true;
        float4 debugColor = 0;
        switch (_DebugLightingSubMode)
        {
            case DEBUGSCREENSPACETRACING_HIT_SUCCESS:
                debugColor = float4(1, hitSuccessful ? 1 : 0, 0, 1);
                break;
            case DEBUGSCREENSPACETRACING_HI_ZHIT_WEIGHT:
                debugColor = float4(hitWeight, hitWeight, hitWeight, 1);
                break;
            case DEBUGSCREENSPACETRACING_HI_ZPOSITION_NDC:
                debugColor = float4(hitPositionNDC.x, hitPositionNDC.y, 0.5, 1);
                break;
            default:
                applyDebug = false;
                break;
        }

        if (applyDebug)
            _DebugTexture[positionSS] = debugColor;
    }
#endif

    _SSReflectionResolveNextTexture[positionSS] = color;
}

#endif