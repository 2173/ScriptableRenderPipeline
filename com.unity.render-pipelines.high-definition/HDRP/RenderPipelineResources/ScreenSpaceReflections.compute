#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64
#define USE_COMPRESSED_BAYER4

#define LOAD_DEVICE_DEPTH(positionSS, level) LoadDeviceDepth(positionSS, level)
float LoadDeviceDepth(uint2 positionSS, int level);

#define LIGHTLOOP_TILE_PASS 1
// deferred opaque always use FPTL
#define USE_FPTL_LIGHTLIST 1
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl

#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PROJECTIONMODEL=PROJECTIONMODEL_HI_Z
#pragma kernel KCastRays_Proxy              KNAME=KCastRays_Proxy           PROJECTIONMODEL=PROJECTIONMODEL_PROXY
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PROJECTIONMODEL=PROJECTIONMODEL_HI_Z     DEBUG_DISPLAY
#pragma kernel KCastRays_Debug_Proxy        KNAME=KCastRays_Debug_Proxy     PROJECTIONMODEL=PROJECTIONMODEL_PROXY    DEBUG_DISPLAY

#include "CoreRP/ShaderLibrary/Common.hlsl"
#ifdef DEBUG_DISPLAY
#include "CoreRP/ShaderLibrary/Debug.hlsl"
#endif
#include "CoreRP/ShaderLibrary/GeometricTools.hlsl"
#include "CoreRP/ShaderLibrary/ImageBasedLighting.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "HDRP/ShaderVariables.hlsl"
#include "HDRP/Debug/DebugDisplay.hlsl"
#include "HDRP/Material/Material.hlsl"
#include "HDRP/Material/Builtin/BuiltinData.hlsl"
#include "HDRP/Material/Lit/Lit.cs.hlsl"
#include "HDRP/Lighting/LightDefinition.cs.hlsl"
#include "HDRP/Lighting/Reflection/VolumeProjection.hlsl"

RW_TEXTURE2D(uint4, _SSReflectionRayHitNextTexture);
#ifdef SHADOWS_SHADOWMASK
TEXTURE2D(_ShadowMaskTexture);
#endif
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4, _DebugTexture);
#endif

CBUFFER_START(UnityScreenSpaceReflections)
float4 _SSReflectionRayHitNextSize;             // (x,y) = Actual Pixel Size, (z,w) = 1 / Actual Pixel Size
float4 _SSReflectionRayHitNextScale;            // (x,y) = Screen Scale, z = lod count, w = unused

#ifdef DEBUG_DISPLAY
int     _SSRDebugMode;
int     _SSRDebugMip;
#endif
CBUFFER_END

#define LDS_MIP_MIN 1
#define LDS_MIP_MAX 4
#define LDS_MIP_COUNT (LDS_MIP_MAX - LDS_MIP_MIN + 1)
#define LDS_MIP_LINELENGTH GROUP_SIZE_1D
// we store 16x16 pixels and compress two float in one, so storage is (GROUP_SIZE_2D * 4) / 2
#define LDS_MIP_STORAGE (GROUP_SIZE_2D * 2)
groupshared uint Depth[LDS_MIP_STORAGE * LDS_MIP_COUNT];
groupshared int4 DepthRects[LDS_MIP_COUNT];

void Store4(uint2 ldsMipCoord, int lod, float p00, float p10, float p01, float p11)
{
    uint i0x = (ldsMipCoord.y * LDS_MIP_LINELENGTH + (ldsMipCoord.x >> 1)) + lod * LDS_MIP_STORAGE;
    uint i1x = i0x + LDS_MIP_LINELENGTH;
    Depth[i0x] = f32tof16(p00) | (f32tof16(p10) << 16);
    Depth[i1x] = f32tof16(p01) | (f32tof16(p11) << 16);
}

float Load1(int2 ldsMipCoord, int lod)
{
    uint index = (ldsMipCoord.y * LDS_MIP_LINELENGTH + (ldsMipCoord.x >> 1)) + lod * LDS_MIP_STORAGE;
    uint payload = Depth[index];
    float p1 = f16tof32(payload);
    float p2 = f16tof32(payload >> 16);
    float mask = (ldsMipCoord.x & 1);
    return mask == 1 ? p2 : p1;
}

bool LoadDeviceDepthFromLDS(uint2 positionTXS, int lod, out float deviceDepth)
{
    if (lod >= LDS_MIP_MIN && lod <= LDS_MIP_MAX)
    {
        lod -= LDS_MIP_MIN;
        int4 rects = DepthRects[lod];
        rects = int4(int2(positionTXS) - rects.xy, rects.zw - int2(positionTXS));
        if (all(rects >= 0))
        {
            deviceDepth = Load1(rects.xy, lod);
            return true;
        }
    }
    deviceDepth = 0;
    return false;
}

float LoadDeviceDepth(uint2 positionTXS, int lod)
{
    positionTXS = positionTXS >> lod;
    float depth = 0;

    UNITY_BRANCH
    if (LoadDeviceDepthFromLDS(positionTXS, lod, depth))
        return depth;

    return LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionTXS, lod).x;
}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_GroupThreadID
)
{
    groupThreadId &= GROUP_SIZE_2D - 1;

    uint2 groupCoord        = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord  = DecodeMorton2D(groupThreadId);
    uint2 positionTXS       = groupCoord + groupThreadCoord;

    uint2 tileCoord         = uint2(0, 0);
    uint  featureFlags      = 0;
    EnvLightData envLightData;
    ZERO_INITIALIZE(EnvLightData, envLightData);

    // -------------------------------
    // Load Depth Pyramid in LDS
    // -------------------------------
    const uint2 d = uint2(0, 1);

    // Load 16x16 pixels centered on the 8x8 wavefront
    // Each thread load 4 pixels into LDS
#define LOAD_DEPTH_LDS(mip)\
    {\
        int2 srcMipGroupCoord   = int2(groupCoord >> mip) - 4;\
        uint2 ldsMipCoord       = (groupThreadCoord << 1);\
        uint2 srcMipCoord       = srcMipGroupCoord + ldsMipCoord;\
        float d00               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.xx, mip).r;\
        float d10               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.yx, mip).r;\
        float d01               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.xy, mip).r;\
        float d11               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.yy, mip).r;\
        Store4(ldsMipCoord, mip - LDS_MIP_MIN, d00, d10, d01, d11);\
\
        if (groupThreadId == (mip - LDS_MIP_MIN))\
            DepthRects[mip - LDS_MIP_MIN] = int4(max(srcMipGroupCoord, int2(0, 0)), srcMipGroupCoord + LDS_MIP_LINELENGTH * 2);\
        GroupMemoryBarrierWithGroupSync();\
    }

    LOAD_DEPTH_LDS(1)
    LOAD_DEPTH_LDS(2)
    LOAD_DEPTH_LDS(3)
    LOAD_DEPTH_LDS(4)

#undef LOAD_DEPTH_LDS

#ifdef DEBUG_DISPLAY
    uint mipToDebug = 1;
    if (_SSRDebugMode == 0)
    {
        float depth;
        LoadDeviceDepthFromLDS((positionTXS >> mipToDebug), mipToDebug, depth);
        _DebugTexture[positionTXS] = float4(float3(1, 1, 1) * frac(LinearEyeDepth(depth, _ZBufferParams) * 0.1), 1);
    }
#endif

    // -------------------------------
    // Decode pixel data
    // -------------------------------
    float depth = LoadDeviceDepth(positionTXS, 0);

    // float depth = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionTXS, 0).r;
    PositionInputs posInput = GetPositionInput(positionTXS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);

    float3 V = GetWorldSpaceNormalizeViewDir(posInput.positionWS);

    // Temporary
    // TODO: create a DECODE_FROM_GBUFFER_SSR to decode only normal and roughness
    BSDFData bsdfData;
    BakeLightingData bakeLightingData;
    DECODE_FROM_GBUFFER(posInput.positionSS, featureFlags, bsdfData, bakeLightingData.bakeDiffuseLighting);
    // End temporary

    // -------------------------------
    // Initialize screen space tracing
    // -------------------------------
    float3 rayOriginWS              = posInput.positionWS;
    float3 rayDirWS                 = reflect(-V, bsdfData.normalWS);

#if DEBUG_DISPLAY
    int debugMode                   = DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION;
    bool debug                      = _DebugLightingMode == debugMode
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(posInput.positionSS));
#endif

    // -------------------------------
    // Screen space tracing query
    // -------------------------------
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;
    float hitWeight = 1;

    // -------------------------------
    // Proxy raycasting
    // -------------------------------
#if PROJECTIONMODEL == PROJECTIONMODEL_PROXY
    ScreenSpaceProxyRaycastInput ssRayInput = CreateScreenSpaceProxyRaycastInput(
        rayOriginWS,
        rayDirWS,
        envLightData
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceProxyRaycastReflection(ssRayInput, hit);

    // -------------------------------
    // HiZ raymarching
    // -------------------------------
#elif PROJECTIONMODEL == PROJECTIONMODEL_HI_Z
    ScreenSpaceRaymarchInput ssRayInput = CreateScreenSpaceHiZRaymarchInput(
        rayOriginWS,
        rayDirWS,
        posInput.positionSS
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceHiZRaymarchReflection(ssRayInput, hit, hitWeight);
#endif

    uint4 payload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, payload);

    _SSReflectionRayHitNextTexture[positionTXS] = payload;
}