#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64

#define LOAD_DEVICE_DEPTH(positionSS, level) LoadDeviceDepth(positionSS, level)
float LoadDeviceDepth(uint2 positionSS, int level);

#define LIGHTLOOP_TILE_PASS 1
// deferred opaque always use FPTL
#define USE_FPTL_LIGHTLIST 1
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl

#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PROJECTIONMODEL=PROJECTIONMODEL_HI_Z
#pragma kernel KCastRays_Proxy              KNAME=KCastRays_Proxy           PROJECTIONMODEL=PROJECTIONMODEL_PROXY
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PROJECTIONMODEL=PROJECTIONMODEL_HI_Z     DEBUG_DISPLAY
#pragma kernel KCastRays_Debug_Proxy        KNAME=KCastRays_Debug_Proxy     PROJECTIONMODEL=PROJECTIONMODEL_PROXY    DEBUG_DISPLAY

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/GeometricTools.hlsl"
#include "CoreRP/ShaderLibrary/ImageBasedLighting.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "HDRP/ShaderVariables.hlsl"
#include "HDRP/Debug/DebugDisplay.hlsl"
#include "HDRP/Material/Material.hlsl"
#include "HDRP/Material/Builtin/BuiltinData.hlsl"
#include "HDRP/Material/Lit/Lit.cs.hlsl"
#include "HDRP/Lighting/LightDefinition.cs.hlsl"
#include "HDRP/Lighting/Reflection/VolumeProjection.hlsl"

RW_TEXTURE2D(uint4, _SSReflectionRayHitNextTexture);
#ifdef SHADOWS_SHADOWMASK
TEXTURE2D(_ShadowMaskTexture);
#endif

CBUFFER_START(UnityScreenSpaceReflections)
float4 _SSReflectionRayHitNextSize;             // (x,y) = Actual Pixel Size, (z,w) = 1 / Actual Pixel Size
float4 _SSReflectionRayHitNextScale;            // (x,y) = Screen Scale, z = lod count, w = unused
CBUFFER_END

#define LDS_MIP_COUNT 5
#define LDS_MIP_LINELENGTH 16
#define LDS_MIP_STORAGE 64
groupshared uint4 DepthRects[LDS_MIP_COUNT];
groupshared float Depth00[LDS_MIP_STORAGE];
groupshared float Depth01[LDS_MIP_STORAGE];
groupshared float Depth02[LDS_MIP_STORAGE];
groupshared float Depth03[LDS_MIP_STORAGE];
groupshared float Depth04[LDS_MIP_STORAGE];
//groupshared float Depth05[LDS_MIP_STORAGE];
//groupshared float Depth06[LDS_MIP_STORAGE];

float LoadDeviceDepth(uint2 positionSS, int level)
{
    if (level < 1)
    {
        uint4 rects = DepthRects[level];
        if (all(positionSS.xy > rects.xy) && all(positionSS.xy < rects.zw))
        {
            uint2 relPositionSS = positionSS - rects.xy;
            // uint2 waveThreadCoord = relPositionSS >> 1;
            // uint storeCoord = waveThreadCoord.y * LDS_MIP_LINELENGTH + waveThreadCoord.x + ((relPositionSS.x & 1) + (relPositionSS.y & 1) * 2);
            uint storeCoord = relPositionSS.y * LDS_MIP_LINELENGTH + LDS_MIP_LINELENGTH.x;
            switch (level)
            {
                case 0: return Depth00[storeCoord];
                case 1: return Depth01[storeCoord];
                case 2: return Depth02[storeCoord];
                case 3: return Depth03[storeCoord];
                case 4: return Depth04[storeCoord];
                // case 5: return Depth05[storeCoord];
                // case 6: return Depth06[storeCoord];
                default: break;
            }
        }
    }
    return LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionSS >> level, level).x;
}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_GroupThreadID
)
{
    groupThreadId &= GROUP_SIZE_2D - 1;

    // We have only one wavefront for a group size of 8
#if GROUP_SIZE_1D == 8
    uint waveIndex              = 0;
    uint2 waveCoord             = uint2(0, 0) * GROUP_SIZE_1D;
#else
    uint waveIndex              = WaveReadFirstLane(groupThreadId / WAVEFRONT_SIZE);
    uint2 waveCoord             = DecodeMorton2D(waveIndex) * GROUP_SIZE_1D;
#endif

    uint2 groupOffset           = groupId * GROUP_SIZE_1D;
    uint2 waveOffset            = groupOffset + waveCoord;
    uint2 waveThreadCoord       = DecodeMorton2D(groupThreadId);
    uint2 pixelCoord            = waveOffset + waveThreadCoord;

    uint2 tileCoord         = uint2(0, 0);
    uint  featureFlags      = UINT_MAX;
    EnvLightData envLightData;
    ZERO_INITIALIZE(EnvLightData, envLightData);

    // -------------------------------
    // Load Depth Pyramid in LDS
    // -------------------------------
    const uint2 d = uint2(0, 1);

#define LOAD_DEPTH_LDS(mip)\
    {\
        uint2 topLeftCoord = (groupOffset << mip) - 4;\
        uint2 loadCoord = topLeftCoord + waveThreadCoord << 1;\
        uint storeCoord = waveThreadCoord.y * LDS_MIP_LINELENGTH + waveThreadCoord.x;\
        float d00 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, loadCoord + d.xx, mip).r;\
        float d10 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, loadCoord + d.yx, mip).r;\
        float d01 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, loadCoord + d.xy, mip).r;\
        float d11 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, loadCoord + d.yy, mip).r;\
        MERGE_NAME(Depth, mip)[storeCoord + 0] = d00;\
        MERGE_NAME(Depth, mip)[storeCoord + 1] = d10;\
        MERGE_NAME(Depth, mip)[storeCoord + LDS_MIP_LINELENGTH + 0] = d01;\
        MERGE_NAME(Depth, mip)[storeCoord + LDS_MIP_LINELENGTH + 1] = d11;\
\
        if (groupThreadId == mip)\
            DepthRects[mip] = uint4(topLeftCoord, topLeftCoord + LDS_MIP_LINELENGTH);\
    }

    LOAD_DEPTH_LDS(00);
    LOAD_DEPTH_LDS(01);
    LOAD_DEPTH_LDS(02);
    LOAD_DEPTH_LDS(03);
    LOAD_DEPTH_LDS(04);
    // LOAD_DEPTH_LDS(05);
    // LOAD_DEPTH_LDS(06);

#undef LOAD_DEPTH_LDS

    GroupMemoryBarrierWithGroupSync();

    // -------------------------------
    // Decode pixel data
    // -------------------------------
    float depth = LoadDeviceDepth(pixelCoord, 0);

    // float depth = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, pixelCoord, 0).r;
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);

    float3 V = GetWorldSpaceNormalizeViewDir(posInput.positionWS);

    BSDFData bsdfData;
    BakeLightingData bakeLightingData;
    DECODE_FROM_GBUFFER(posInput.positionSS, featureFlags, bsdfData, bakeLightingData.bakeDiffuseLighting);
    #ifdef SHADOWS_SHADOWMASK
    DecodeShadowMask(LOAD_TEXTURE2D(_ShadowMaskTexture, posInput.positionSS), bakeLightingData.bakeShadowMask);
    #endif

    PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);

    // -------------------------------
    // Initialize screen space tracing
    // -------------------------------
    float3 rayOriginWS              = posInput.positionWS;
    float3 rayDirWS                 = preLightData.iblR;

#if DEBUG_DISPLAY
    int debugMode                   = DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION;
    bool debug                      = _DebugLightingMode == debugMode
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(posInput.positionSS));
#endif

    // -------------------------------
    // Screen space tracing query
    // -------------------------------
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;
    float hitWeight = 1;

    // -------------------------------
    // Proxy raycasting
    // -------------------------------
#if PROJECTIONMODEL == PROJECTIONMODEL_PROXY
    ScreenSpaceProxyRaycastInput ssRayInput = CreateScreenSpaceProxyRaycastInput(
        rayOriginWS,
        rayDirWS,
        envLightData
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceProxyRaycastReflection(ssRayInput, hit);

    // -------------------------------
    // HiZ raymarching
    // -------------------------------
#elif PROJECTIONMODEL == PROJECTIONMODEL_HI_Z
    ScreenSpaceRaymarchInput ssRayInput = CreateScreenSpaceHiZRaymarchInput(
        rayOriginWS,
        rayDirWS,
        posInput.positionSS
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceHiZRaymarchReflection(ssRayInput, hit, hitWeight);
#endif

    uint4 payload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, payload);

    _SSReflectionRayHitNextTexture[pixelCoord] = payload;
}