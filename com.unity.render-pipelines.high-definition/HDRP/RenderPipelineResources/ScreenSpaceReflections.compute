#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#define PASS_CAST_RAYS 0
#define PASS_ALLOCATE_RAYS 1

// -------------------------------------------------
// Kernels Settings
// -------------------------------------------------
#if PASS == PASS_CAST_RAYS
// Kernel settings
#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64
#define USE_COMPRESSED_BAYER4

#elif PASS == PASS_ALLOCATE_RAYS
// Kernel settings
#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64
#define USE_COMPRESSED_BAYER4

#endif

// -------------------------------------------------
// Kernels
// -------------------------------------------------
#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PASS=PASS_CAST_RAYS     PROJECTIONMODEL=PROJECTIONMODEL_HI_Z
#pragma kernel KCastRays_Proxy              KNAME=KCastRays_Proxy           PASS=PASS_CAST_RAYS     PROJECTIONMODEL=PROJECTIONMODEL_PROXY
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PASS=PASS_CAST_RAYS     PROJECTIONMODEL=PROJECTIONMODEL_HI_Z     DEBUG_DISPLAY
#pragma kernel KCastRays_Debug_Proxy        KNAME=KCastRays_Debug_Proxy     PASS=PASS_CAST_RAYS     PROJECTIONMODEL=PROJECTIONMODEL_PROXY    DEBUG_DISPLAY
#pragma kernel KAllocateRays_HiZ            KNAME=KAllocateRays_HiZ         PASS=PASS_ALLOCATE_RAYS

// -------------------------------------------------
// Common includes of passes
// -------------------------------------------------
#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#define LIGHTLOOP_TILE_PASS 1
// deferred opaque always use FPTL
#define USE_FPTL_LIGHTLIST 1
#include "CoreRP/ShaderLibrary/GeometricTools.hlsl"
#include "CoreRP/ShaderLibrary/ImageBasedLighting.hlsl"
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl
#include "HDRP/ShaderVariables.hlsl"
#include "HDRP/Material/Material.hlsl"
#include "HDRP/Material/Builtin/BuiltinData.hlsl"
#include "HDRP/Material/Lit/Lit.cs.hlsl"
#include "HDRP/Lighting/LightDefinition.cs.hlsl"
#include "HDRP/Lighting/Reflection/VolumeProjection.hlsl"
#ifdef DEBUG_DISPLAY
#include "CoreRP/ShaderLibrary/Debug.hlsl"
#include "HDRP/Debug/DebugDisplay.hlsl"
#endif

// -------------------------------------------------
// Common functions
// -------------------------------------------------
void DecodeInput(uint2 positionSS, out float3 positionWS, out float depth, out float3 V)
{
    depth                       = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionSS, 0).x;
    PositionInputs posInput     = GetPositionInput(positionSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, int2(0, 0));
    V                           = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    positionWS                  = posInput.positionWS;
}

void DecodeGBufferSSR(uint2 positionSS, out float3 normalWS, out float perceptualRoughness)
{
    BSDFData bsdfData;
    BakeLightingData bakeLightingData;
    DECODE_FROM_GBUFFER(positionSS, 0, bsdfData, bakeLightingData.bakeDiffuseLighting);
    normalWS            = bsdfData.normalWS;
    perceptualRoughness = bsdfData.perceptualRoughness;
}

void DecodeThreadGroup(uint groupThreadId, uint2 groupId, out uint2 groupCoord, out uint2 groupThreadCoord, uint2 positionTXS)
{
    groupThreadId &= GROUP_SIZE_2D - 1;

    groupCoord              = groupId * GROUP_SIZE_1D;
    groupThreadCoord        = DecodeMorton2D(groupThreadId);
    positionTXS             = groupCoord + groupThreadCoord;
}

void EncodeRayAllocation(float3 startPositionSS, float3 raySS, float rayEndDepth, bool debug, out uint4 payload)
{
    payload.x = f32tof16(startPositionSS.x) | (f32tof16(startPositionSS.y) << 16);
    payload.y = f32tof16(startPositionSS.z) | (f32tof16(raySS.x) << 16);
    payload.z = f32tof16(raySS.y) | (f32tof16(raySS.z) << 16);
    payload.w = f32tof16(rayEndDepth) | ((debug ? 1 : 0) << 16);
}

void DecodeRayAllocation(uint4 payload, out float3 startPositionSS, out float3 raySS, out float rayEndDepth, out bool debug)
{
    startPositionSS     = float3(f16tof32(payload.x), f16tof32(payload.x >> 16), f16tof32(payload.y));
    raySS               = float3(f16tof32(payload.y >> 16), f16tof32(payload.z), f16tof32(payload.z >> 16));
    rayEndDepth         = f16tof32(payload.z);
    debug               = (payload.w & (1 << 17)) != 0;
}

// #################################################
// Pass: Cast Rays
// #################################################
// Cast rays in screen space and store the hit in a buffer
// -------------------------------------------------
#if PASS == PASS_CAST_RAYS

#if PROJECTIONMODEL == PROJECTIONMODEL_HI_Z
// Setup the function to load depth from LDS (only HiZ)
#define LOAD_DEVICE_DEPTH(positionSS, level) LoadDeviceDepth(positionSS, level)
float LoadDeviceDepth(uint2 positionSS, int level);
#endif

// Resources
RW_TEXTURE2D(uint4, _SSReflectionRayHitNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4, _DebugTexture);
#endif

// CBuffers
CBUFFER_START(UnityScreenSpaceReflections)
float4 _SSReflectionRayHitNextSize;             // (x,y) = Actual Pixel Size, (z,w) = 1 / Actual Pixel Size
float4 _SSReflectionRayHitNextScale;            // (x,y) = Screen Scale, z = lod count, w = unused

#ifdef DEBUG_DISPLAY
int     _SSRDebugMode;
int     _SSRDebugMip;
#endif
CBUFFER_END

// -------------------------------------------------
// Entry point: Cast Rays (Proxy)
// -------------------------------------------------
#if PROJECTIONMODEL == PROJECTIONMODEL_PROXY
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_GroupThreadID
)
{
    // -------------------------------
    // Decode pixel data
    // -------------------------------
    uint2 groupCoord;
    uint2 groupThreadCoord;
    uint2 positionTXS;
    DecodeThreadGroup(groupThreadId, groupId, groupCoord, groupThreadCoord, positionTXS);

    float depth;
    float3 V;
    float3 positionWS;
    DecodeInput(positionTXS, positionTXS, depth, V);
    float3 normalWS;
    float perceptualRoughness;
    DecodeGBufferSSR(positionTXS, normalWS, perceptualRoughness);

    // TODO: decode proxy data
    EnvLightData envLightData;
    ZERO_INITIALIZE(EnvLightData, envLightData);

    // -------------------------------
    // Initialize screen space tracing
    // -------------------------------
    float3 rayOriginWS              = positionWS;
    float3 rayDirWS                 = reflect(-V, normalWS);

#if DEBUG_DISPLAY
    int debugMode                   = DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION;
    bool debug                      = _DebugLightingMode == debugMode
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(positionTXS));
#endif

    // -------------------------------
    // Screen space tracing query
    // -------------------------------
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;

    ScreenSpaceProxyRaycastInput ssRayInput = CreateScreenSpaceProxyRaycastInput(
        rayOriginWS,
        rayDirWS,
        envLightData
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceProxyRaycastReflection(ssRayInput, hit);

    uint4 payload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, 1, hitSuccessful, payload);

    _SSReflectionRayHitNextTexture[positionTXS] = payload;
}

// -------------------------------------------------
// Entry point: Cast Rays (HiZ)
// -------------------------------------------------
#elif PROJECTIONMODEL == PROJECTIONMODEL_HI_Z

Texture2D<uint4> _SSReflectionRayAllocationTexture;

// LDS Definition And Utility Functions
// We load some mips of the Depth Pyramid in the LDS to save Texture Bandwidth
#define LDS_MIP_MIN 1
#define LDS_MIP_MAX 2
#define LDS_MIP_COUNT (LDS_MIP_MAX - LDS_MIP_MIN + 1)
#define LDS_MIP_LINELENGTH GROUP_SIZE_1D
// we store 16x16 pixels and compress two float in one, so storage is (GROUP_SIZE_2D * 4) / 2
#define LDS_MIP_STORAGE (GROUP_SIZE_2D * 2)
groupshared uint Depth[LDS_MIP_STORAGE * LDS_MIP_COUNT];
groupshared int4 DepthRects[LDS_MIP_COUNT];

void Store4(uint2 ldsMipCoord, int lod, float p00, float p10, float p01, float p11)
{
    uint i0x = (ldsMipCoord.y * LDS_MIP_LINELENGTH + (ldsMipCoord.x >> 1)) + lod * LDS_MIP_STORAGE;
    uint i1x = i0x + LDS_MIP_LINELENGTH;
    Depth[i0x] = f32tof16(p00) | (f32tof16(p10) << 16);
    Depth[i1x] = f32tof16(p01) | (f32tof16(p11) << 16);
}

float Load1(int2 ldsMipCoord, int lod)
{
    uint index = (ldsMipCoord.y * LDS_MIP_LINELENGTH + (ldsMipCoord.x >> 1)) + lod * LDS_MIP_STORAGE;
    uint payload = Depth[index];
    float p1 = f16tof32(payload);
    float p2 = f16tof32(payload >> 16);
    float mask = (ldsMipCoord.x & 1);
    return mask == 1 ? p2 : p1;
}

bool LoadDeviceDepthFromLDS(uint2 positionTXS, int lod, out float deviceDepth)
{
    if (lod >= LDS_MIP_MIN && lod <= LDS_MIP_MAX)
    {
        lod -= LDS_MIP_MIN;
        int4 rects = DepthRects[lod];
        rects = int4(int2(positionTXS) - rects.xy, rects.zw - int2(positionTXS));
        if (all(rects >= 0))
        {
            deviceDepth = Load1(rects.xy, lod);
            return true;
        }
    }
    deviceDepth = 0;
    return false;
}

float LoadDeviceDepth(uint2 positionTXS, int lod)
{
    positionTXS = positionTXS >> lod;
    float depth = 0;

    UNITY_BRANCH
    if (LoadDeviceDepthFromLDS(positionTXS, lod, depth))
        return depth;

    return LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionTXS, lod).x;
}


[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_GroupThreadID
)
{
    uint2 groupCoord;
    uint2 groupThreadCoord;
    uint2 positionTXS;
    DecodeThreadGroup(groupThreadId, groupId, groupCoord, groupThreadCoord, positionTXS);
    
    // -------------------------------
    // Load Depth Pyramid in LDS
    // -------------------------------
    const uint2 d = uint2(0, 1);

    // Load 16x16 pixels centered on the 8x8 wavefront
    // Each thread load 4 pixels into LDS
#define LOAD_DEPTH_LDS(mip)\
    {\
        int2 srcMipGroupCoord   = int2(groupCoord >> mip) - 4;\
        uint2 ldsMipCoord       = (groupThreadCoord << 1);\
        uint2 srcMipCoord       = srcMipGroupCoord + ldsMipCoord;\
        float d00               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.xx, mip).r;\
        float d10               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.yx, mip).r;\
        float d01               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.xy, mip).r;\
        float d11               = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, srcMipCoord + d.yy, mip).r;\
        Store4(ldsMipCoord, mip - LDS_MIP_MIN, d00, d10, d01, d11);\
\
        if (groupThreadId == (mip - LDS_MIP_MIN))\
            DepthRects[mip - LDS_MIP_MIN] = int4(max(srcMipGroupCoord, int2(0, 0)), srcMipGroupCoord + LDS_MIP_LINELENGTH * 2);\
        GroupMemoryBarrierWithGroupSync();\
    }

    LOAD_DEPTH_LDS(1)
    LOAD_DEPTH_LDS(2)
    // LOAD_DEPTH_LDS(3)
    // LOAD_DEPTH_LDS(4)

#undef LOAD_DEPTH_LDS

#ifdef DEBUG_DISPLAY
    uint mipToDebug = 1;
    if (_SSRDebugMode == 0)
    {
        float depth;
        LoadDeviceDepthFromLDS((positionTXS >> mipToDebug), mipToDebug, depth);
        _DebugTexture[positionTXS] = float4(float3(1, 1, 1) * frac(LinearEyeDepth(depth, _ZBufferParams) * 0.1), 1);
    }
#endif

    // -------------------------------
    // Decode pixel data
    // -------------------------------
    uint4 inputPayload = _SSReflectionRayAllocationTexture[positionTXS];
    float3 startPositionSS;
    float3 raySS;
    float rayEndDepth;
    bool debug;
    DecodeRayAllocation(inputPayload, startPositionSS, raySS, rayEndDepth, debug);

    // -------------------------------
    // Screen space tracing query
    // -------------------------------
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;
    float hitWeight = 1;

    ScreenSpaceRaymarchInputPrecomputed ssRayInput;
    ssRayInput.startPositionSS      = startPositionSS;
    ssRayInput.raySS                = raySS;
    ssRayInput.rayEndDepth          = rayEndDepth;
#ifdef DEBUG_DISPLAY
    ssRayInput.debug                = debug;
#endif

    hitSuccessful = ScreenSpaceHiZRaymarchReflection(ssRayInput, hit, hitWeight);

    uint4 outputPayload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, outputPayload);

    _SSReflectionRayHitNextTexture[positionTXS] = outputPayload;
}
#endif

// #################################################
// Pass: Allocate Rays
// #################################################
// HiZ only
// Calculate initialization values for HiZ algorithm
// -------------------------------------------------
#elif PASS == PASS_ALLOCATE_RAYS

// -------------------------------------------------
// Entry point: Allocate Rays
// -------------------------------------------------
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_GroupThreadID
)
{
    // -------------------------------
    // Decode pixel data
    // -------------------------------
    uint2 groupCoord;
    uint2 groupThreadCoord;
    uint2 positionTXS;
    DecodeThreadGroup(groupThreadId, groupId, groupCoord, groupThreadCoord, positionTXS);

    float depth;
    float3 V;
    float3 positionWS;
    DecodeInput(positionTXS, positionWS, depth, V);
    float3 normalWS;
    float perceptualRoughness;
    DecodeGBufferSSR(positionTXS, normalWS, perceptualRoughness);

    float3 rayOriginWS              = positionWS;
    float3 rayDirWS                 = reflect(-V, normalWS);
    bool debug                      = false;

#if DEBUG_DISPLAY
    debug                           = _DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(positionTXS));
#endif

    ScreenSpaceRaymarchInput ssRayInput = CreateScreenSpaceHiZRaymarchInput(
        rayOriginWS,
        rayDirWS,
        positionTXS
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    
    float3 startPositionSS;
    float3 raySS;
    float rayEndDepth;
    CalculateRaySS(
        ssRayInput.rayOriginWS,
        ssRayInput.rayDirWS,
        uint2(_DepthPyramidSize.xy),
        startPositionSS,
        raySS,
        rayEndDepth
    );

    uint4 payload = uint4(0, 0, 0, 0);
    EncodeRayAllocation(startPositionSS, raySS, rayEndDepth, debug, payload);
}
#endif