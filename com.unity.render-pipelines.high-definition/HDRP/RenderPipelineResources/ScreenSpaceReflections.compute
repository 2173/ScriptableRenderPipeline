#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// -------------------------------------------------
// Screen Space Reflection
// -------------------------------------------------
// Proxy passes
// 1. Cast Rays
// 2. Resolve color
//
// Raytracing passes
// 1. Clear buffers
// 2. Allocate rays
// 3. Cast rays
// 4. Resolve color
// -------------------------------------------------

#define PASS_CLEAR 0
#define PASS_CAST_RAYS 1
#define PASS_ALLOCATE_RAYS 2
#define PASS_RESOLVE 3

// -------------------------------------------------
// Kernels Settings
// -------------------------------------------------
// Kernel settings
#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64

#if PASS == PASS_CLEAR
#elif PASS == PASS_CAST_RAYS
#elif PASS == PASS_ALLOCATE_RAYS
    #define USE_COMPRESSED_BAYER4
#endif

// -------------------------------------------------
// Kernels
// -------------------------------------------------
#pragma kernel KClear                       KNAME=KClear                    PASS=PASS_CLEAR
#pragma kernel KAllocateRays_HiZ            KNAME=KAllocateRays_HiZ         PASS=PASS_ALLOCATE_RAYS
#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PASS=PASS_CAST_RAYS         PROJECTIONMODEL=PROJECTIONMODEL_HI_Z
#pragma kernel KCastRays_Proxy              KNAME=KCastRays_Proxy           PASS=PASS_CAST_RAYS         PROJECTIONMODEL=PROJECTIONMODEL_PROXY
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PASS=PASS_CAST_RAYS         PROJECTIONMODEL=PROJECTIONMODEL_HI_Z     DEBUG_DISPLAY
#pragma kernel KCastRays_Debug_Proxy        KNAME=KCastRays_Debug_Proxy     PASS=PASS_CAST_RAYS         PROJECTIONMODEL=PROJECTIONMODEL_PROXY    DEBUG_DISPLAY

// -------------------------------------------------
// Common includes of passes
// -------------------------------------------------
#if PROJECTIONMODEL == PROJECTIONMODEL_HI_Z && defined(PASS_CASTRAYS_USE_LDS)
// Setup the function to load depth from LDS (only HiZ)
#define LOAD_DEVICE_DEPTH(positionSS, level) LoadDeviceDepth(positionSS, level)
float LoadDeviceDepth(uint2 positionSS, int level);
#endif

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#define LIGHTLOOP_TILE_PASS 1
// deferred opaque always use FPTL
#define USE_FPTL_LIGHTLIST 1
#include "CoreRP/ShaderLibrary/GeometricTools.hlsl"
#include "CoreRP/ShaderLibrary/ImageBasedLighting.hlsl"
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl
#include "HDRP/ShaderVariables.hlsl"
#include "HDRP/Debug/DebugDisplay.hlsl"
#include "HDRP/Material/Material.hlsl"
#include "HDRP/Material/Builtin/BuiltinData.hlsl"
#include "HDRP/Material/Lit/Lit.cs.hlsl"
#include "HDRP/Lighting/LightDefinition.cs.hlsl"
#include "HDRP/Lighting/Reflection/VolumeProjection.hlsl"
#ifdef DEBUG_DISPLAY
#include "CoreRP/ShaderLibrary/Debug.hlsl"
#endif

// -------------------------------------------------
// Common
// -------------------------------------------------
struct AllocationPayload
{
    uint2 positionSS;
};

uint EncodeAllocationPayload(AllocationPayload payload)
{
    return (payload.positionSS.x & 0xFFFF) | (payload.positionSS.y << 16);
}

AllocationPayload DecodeAllocationPayload(uint payload)
{
    AllocationPayload result;
    result.positionSS.x = (payload & 0xFFFF);
    result.positionSS.y = payload >> 16;
    return result;
}

uint GetIndex(uint2 groupId, uint groupThreadId)
{
    uint groupPerRow = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    return groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D + 3;
}

void DecodeGBufferSSR(uint2 positionSS, out float3 normalWS, out float perceptualRoughness)
{
    BSDFData bsdfData;
    BakeLightingData bakeLightingData;
    DECODE_FROM_GBUFFER(positionSS, 0, bsdfData, bakeLightingData.bakeDiffuseLighting);
    normalWS            = bsdfData.normalWS;
    perceptualRoughness = bsdfData.perceptualRoughness;
}

// #################################################
// Pass: Clear
// #################################################
// Clear buffers
// -------------------------------------------------
#if PASS == PASS_CLEAR

RWStructuredBuffer<uint>    _Payload;

[numthreads(1, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    // Clear allocated dispatch indirect buffer
    _Payload[0] = 0;
    _Payload[1] = 1;
    _Payload[2] = 1;
}

// #################################################
// Pass: Allocate Rays
// #################################################
// HiZ only
// Calculate initialization values for HiZ algorithm
// -------------------------------------------------
#elif PASS == PASS_ALLOCATE_RAYS

RWStructuredBuffer<uint>    _Payload;
RWBuffer<float4>            _Payload1;
RWBuffer<float4>            _Payload2;

// -------------------------------------------------
// Entry point: Allocate Rays
// -------------------------------------------------
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    if (groupThreadId == 0)
        InterlockedAdd(_Payload[0], 1);

    groupThreadId &= GROUP_SIZE_2D - 1;

    uint groupPerRow        = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    uint index              = groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D + 3;
    uint2 groupCoord        = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord  = DecodeMorton2D(groupThreadId);
    uint2 positionSS        = groupCoord + groupThreadCoord;

    // Decode GBuffer
    float depth                 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionSS, 0).x;
    PositionInputs posInput     = GetPositionInput(positionSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, int2(0, 0));
    float3 V                    = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    float3 positionWS           = posInput.positionWS;
    float3 normalWS;
    float perceptualRoughness;
    DecodeGBufferSSR(positionSS, normalWS, perceptualRoughness);

    // Calculate ray endpoints
    float3 rayOriginWS              = positionWS;
    float3 rayDirWS                 = reflect(-V, normalWS);

    float3 startPositionSS;
    float3 endPositionSS;
    CalculateRayEndPointSS(
        rayOriginWS + rayDirWS * SampleBayer4(positionSS + uint2(_FrameCount, uint(_FrameCount) / 4u)) * 0.1,
        rayDirWS,
        uint2(_DepthPyramidSize.xy),
        startPositionSS,
        endPositionSS
    );

    // Save payload
    AllocationPayload allocationPayload;
    allocationPayload.positionSS = positionSS;

    _Payload[index]     = EncodeAllocationPayload(allocationPayload);
    _Payload1[index]    = float4(startPositionSS, 1);
    _Payload2[index]    = endPositionSS.xyzz;
}

// #################################################
// Pass: Cast Rays
// #################################################
// Cast rays in screen space and store the hit in a buffer
// -------------------------------------------------
#elif PASS == PASS_CAST_RAYS

// Resources
RW_TEXTURE2D(uint4, _SSReflectionRayHitNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4, _DebugTexture);
#endif

// CBuffers
CBUFFER_START(UnityScreenSpaceReflections)
float4 _SSReflectionRayHitNextSize;             // (x,y) = Actual Pixel Size, (z,w) = 1 / Actual Pixel Size
float4 _SSReflectionRayHitNextScale;            // (x,y) = Screen Scale, z = lod count, w = unused

#ifdef DEBUG_DISPLAY
int     _SSRDebugMode;
int     _SSRDebugMip;
#endif
CBUFFER_END

// -------------------------------------------------
// Entry point: Cast Rays (Proxy)
// -------------------------------------------------
#if PROJECTIONMODEL == PROJECTIONMODEL_PROXY
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId       : SV_GroupID,
    uint  groupThreadId : SV_DispatchThreadID
)
{
    groupThreadId &= GROUP_SIZE_2D - 1;

    uint2 groupCoord        = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord  = DecodeMorton2D(groupThreadId);
    uint2 positionSS        = groupCoord + groupThreadCoord;

    // Decode GBuffer
    float depth                 = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, positionSS, 0).x;
    PositionInputs posInput     = GetPositionInput(positionSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, int2(0, 0));
    float3 V                    = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    float3 positionWS           = posInput.positionWS;
    float3 normalWS;
    float perceptualRoughness;
    DecodeGBufferSSR(positionSS, normalWS, perceptualRoughness);


    // TODO: decode proxy data
    EnvLightData envLightData;
    ZERO_INITIALIZE(EnvLightData, envLightData);

    // -------------------------------
    // Initialize screen space tracing
    // -------------------------------
    float3 rayOriginWS              = positionWS;
    float3 rayDirWS                 = reflect(-V, normalWS);

#if DEBUG_DISPLAY
    int debugMode                   = DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION;
    bool debug                      = _DebugLightingMode == debugMode
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(positionSS));
#endif

    // -------------------------------
    // Screen space tracing query
    // -------------------------------
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;

    ScreenSpaceProxyRaycastInput ssRayInput = CreateScreenSpaceProxyRaycastInput(
        rayOriginWS + rayDirWS * SampleBayer4(positionSS + uint2(_FrameCount, uint(_FrameCount) / 4u)) * 0.1,
        rayDirWS,
        envLightData
#ifdef DEBUG_DISPLAY
        , debug
#endif
    );
    hitSuccessful = ScreenSpaceProxyRaycastReflection(ssRayInput, hit);

    uint4 payload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, 1, hitSuccessful, payload);

    _SSReflectionRayHitNextTexture[positionSS] = payload;
}

// -------------------------------------------------
// Entry point: Cast Rays (HiZ)
// -------------------------------------------------
#elif PROJECTIONMODEL == PROJECTIONMODEL_HI_Z

StructuredBuffer<uint>      _Payload;
Buffer<float4>    _Payload1;
Buffer<float4>    _Payload2;
Texture2D<uint4>            _SSReflectionRayAllocationTexture;

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint dispatchThreadID : SV_DispatchThreadID
)
{
    uint index                      = dispatchThreadID;
    
    // Read allocation payload
    AllocationPayload allocation    = DecodeAllocationPayload(_Payload[index]);
    uint2 positionSS                = allocation.positionSS;
    float3 startRayPositionSS       = _Payload1[index].xyz;
    float3 endRayPositionSS         = _Payload2[index].xyz;
    float3 raySS                    = endRayPositionSS - startRayPositionSS;

    // Screen space tracing query
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful = false;
    float hitWeight = 1;

    ScreenSpaceRaymarchInputPrecomputed ssRayInput;
    ssRayInput.startPositionSS      = startRayPositionSS;
    ssRayInput.raySS                = raySS;
#ifdef DEBUG_DISPLAY
    ssRayInput.debug                = _DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(allocation.positionSS));
#endif

    hitSuccessful = ScreenSpaceHiZRaymarchPrecomputedReflection(ssRayInput, hit, hitWeight);

    uint4 outputPayload = uint4(0, 0, 0, 0);
    PackRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, outputPayload);

    _SSReflectionRayHitNextTexture[positionSS] = outputPayload;
#ifdef DEBUG_DISPLAY
    _DebugTexture[positionSS] = float4(hit.debugOutput, 1);
#endif
}
#endif

#endif